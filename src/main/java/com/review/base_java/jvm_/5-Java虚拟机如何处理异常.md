[《深入拆解 Java 虚拟机》06 | JVM是如何处理异常的？](https://time.geekbang.org/column/article/12134)

---

#### 1. Java中的异常
异常处理分为抛出异常和捕获异常两部分，它们共同实现程序控制流的非正常转移。其中抛出异常分为显式和隐式两种：
- 显式抛异常的主体是应用程序，指的是在程序中使用“throw”关键字，手动将异常实例抛出。
- 隐式抛异常的主体是Java虚拟机，指的是Java虚拟机在执行过程中，碰到无法继续执行的异常状态，自动抛出异常。

捕获异常涉及到如下三种代码块：
- try代码块：用来标记需要进行异常监控的代码。
- catch代码块：跟在try代码块之后，用于捕获在try代码块中触发的某种指定类型的异常。catch代码块可以有多个，Java虚拟机会从上至下匹配异常处理器，因此catch代码块所捕获的异常类型不能覆盖后边的，
否则编译器会报错。
- finally代码块：跟在try代码块和finally代码块之后，用来声明一段必定运行的代码。

#### 2. 异常的基本概念
在Java语言规范中，所有异常都是Throwable类或其子类的实例。Throwable有两大直接子类：
- Error：涵盖程序不应捕获的异常。当程序触发Error时，它的执行状态已经无法恢复，需要中止线程甚至中止虚拟机。
- Exception：涵盖程序可能需要捕获并且处理的异常。Exception 有一个特殊的子类 RuntimeException，用来表示“程序虽然无法继续执行，但是还能抢救一下”的情况。

```
异常实例的构造十分昂贵，这是由于在构造异常实例时，Java虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的Java栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。在生成
栈轨迹时，Java虚拟机会忽略掉异常构造器以及填充栈帧的Java方法（Throwable.fillInStackTrace），直接从新建异常位置开始算起。此外，Java虚拟机还会忽略标记为不可见的Java方法栈帧。
```

#### 3. Java虚拟机如何捕获异常？
在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成（any 指代任意异常类型）。这些指针的值是字节码
索引（bytecode index，bci），用以定位字节码。其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try 代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置。

当程序触发异常时，Java虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。
如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。

finally代码块的编译比较复杂，在当前版本Java编译器中的做法，是复制finally代码块的内容，分别放在try-catch代码块所有正常执行路径已经异常执行路径的出口中。针对异常执行路径，Java编译器会生成一个或多个异常表条目，监控整个try-catch代码块，并且捕获所有种类
的异常。这些异常表条目的target指针将指向另一份复制的finally代码块（即异常流转至某个异常表条目，处理完后会流转至该异常条目target指针指向的字节码 - finally代码块）。若在这个finally代码块没有return，Java编译器会重新抛出所捕获的异常；若在finally代
码块执行完之前return，则异常会被忽略。

#### 4. Java7的Supressed异常以及语法糖
在try-catch-finally中存在一个小问题，如果catch捕获了异常，但又触发了一个新异常，那么finally只会捕获并且重抛新异常，原本的异常会被忽略掉。

Java7中引入了Supressed异常，它允许开发人员将一个异常附于另一个异常之上，但使用起来非常繁琐。为此，Java 7 专门构造了一个名为 try-with-resources 的语法糖，在字节码层面自动使用 Supressed 异常，从而避免原异常“被消失”。当然，该语法糖的主要目的并不是使用
Supressed 异常，而是精简资源打开关闭的用法。