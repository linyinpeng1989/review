[《深入拆解 Java 虚拟机》11 | 垃圾回收（上）](https://time.geekbang.org/column/article/13091)

[《深入拆解 Java 虚拟机》12 | 垃圾回收（下）](https://time.geekbang.org/column/article/13137)

---

#### 1. 引用计数法与可达性分析
在Java虚拟机语境下，垃圾指的是已经死亡的对象所占据的堆空间。如何辨别一个对象是存是亡？
- 引用计数法：为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，可以被回收。
    - 需要额外的空间来存储引用计数器。
    - 繁琐的更新操作：需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。
    - 无法处理循环引用对象，可能会造成内存泄露。

- 可达性分析：将一系列GC Roots作为初始的存活对象集合（live set），然后从该集合触发，探索所有能够被该集合引用到的对象，并将其加入到存活对象集合
中。最终，未被探索到的对象便是死亡的，可以被回收。这个过程可以称之为标记（mark）。
    - GC Roots可以简单地理解为由堆外指向堆内的引用，一般而言包括（但不限于）如下几种：
        - Java方法栈帧中的局部变量
        - 已加载类的静态变量
        - JNI handles
        - 已启动且未停止的Java线程

#### 2. Stop-the-world以及安全点
为了防止在标记过程中堆栈的状态发生改变，Java 虚拟机采取安全点机制来实现 Stop-the-world 操作，暂停其他非垃圾回收线程。

- Stop-the-world：停止其他非垃圾回收线程的工作（并非完全停止），直到完成垃圾回收。这也就造成了垃圾回收的暂停时间。
- 安全点：Java虚拟机中的Stop-the-world是通过安全点机制实现的。当Java虚拟机收到Stop-the-world请求，它便会等待所有线程都到达安全点，才允许请求Stop-the-world的线程进行独占的工作。
安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。

#### 3. 垃圾回收的三种方式
- 标记清除：把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。
    - 会造成内存碎片。由于Java虚拟机的堆中对象的内存必须是连续的，因此可能出现总空闲内存足够，但是无法分配的极端情况。
    - 分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。

- 标记压缩：把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。
    - 能够解决内存碎片化的问题，但代价是压缩算法的性能开销。

- 标记复制：把内存区域分为两等分，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针指向的内存区域中，并且交换 from 指针和 to 指针的内容。
    - 能够解决内存碎片化问题，但堆空间的使用效率较低。


#### 4. Java虚拟机的分代垃圾回收
Java虚拟机将堆划分为新生代和老年代。其中，新生代又被划分为Eden区以及两个大小相同的Survivor区。默认情况下，Java虚拟机采取动态分配策略（对应 Java 虚拟机参数 -XX:+UsePSAdaptiveSurvivorSizePolicy），根据生成对象的速率以及Survivor区的使用情况
动态调整Eden区和Survivor区的比例。当然，也可以通过参数-XX:SurvivorRatio 来固定这个比例。

在调用new指令时，会在Eden区中划出一块作为存储对象的内存（需要加锁同步）。为了提高分配内存的效率，Java虚拟机通过TLAB技术（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启），为线程一次性分配一段连续的内存。接下来的
new指令，便可以直接通过指针加法（bump the pointer）实现，而不需要再去堆中重新申请内存（需要加锁同步）。当分配的内存耗尽后，线程可以再次向堆申请一段连续的内存。

- Minor GC
    - 当Eden区空间耗尽，无法再次分配内存时，Java虚拟机会触发一次Minor GC进行新生代的垃圾回收。当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。
    Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次，达到阈值（对应虚拟机参数 -XX:+MaxTenuringThreshold）后依然存活的对象会晋升到老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。
    - Minor GC使用标记-复制算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。
    - Minor GC存在一个问题：老年代的对象可能引用新生代的对象。在Minor GC时，老年代中引用新生代对象的引用，也需要作为GC Roots。为了避免全堆扫描，Java虚拟机引入了卡表（Card Table）技术，如果卡中可能存在指向新生代对象的引用，则认为是脏卡。
    在进行Minor GC时，不需要扫描整个老年代，只需要在卡表中寻找脏卡，并将脏卡中的对象加入到GC Roots中。

- Full GC 或 Major GC

#### 5. Java虚拟机的垃圾回收器
- 针对新生代
    - Serial：单线程，标记复制算法
    - Parallel New：多线程并行，标记复制算法（Serial的多线程版本）
    - Parallel Scavenge：多线程并行，标记复制算法，不能与CMS仪器使用（与Parallel New类似，但更加注重吞吐率 - 垃圾回收占用的CPU资源更少，但垃圾回收工作量不变，且CPU的处理速率也不变，也就意味着每次垃圾回收的停顿时间更长）

- 针对老年代
    - Serial Old：单线程，标记压缩算法
    - Parallel Old：多线程并行，标记压缩算法（Serial Old的多线程版本）
    - CMS：多行程并发，标记清除算法。除了少数几个操作需要Stop-the-world之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败（Concurrent Mode Failure）的情况下，会使用Serial Old作为后备预案。由于G1的出现，CMS在Java 9中已被废弃。
        - 对CPU非常敏感，并发收集时会占用一部分CPU资源，导致应用程序变慢，总吞吐量降低
        - 无法处理浮动垃圾，可能出现"Concurrent Mode Failure"失败。在并发清除时，用户线程新产生的垃圾被称为浮动垃圾，所以在并发清除时需要预留一定的内存空间，如果CMS预留内存空间无法满足程序需要，就会出现"Concurrent Mode Failure"失败。
        - 采用标记清除算法，可能产生大量内存碎片。可以通过参数设置压缩整理的时机和频率。

- 整堆收集器
    - G1：横跨新生代和老年代，将堆分成极其多个区域，每个区域都可以充当Eden区、Survivor区或者老年代中的一个。它采用标记压缩算法（整体标记压缩算法，局部标记复制算法），多线程并行、并发地进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。

[Java虚拟机垃圾回收(三) 7种垃圾收集器：主要特点 应用场景 设置参数 基本运行原理](https://blog.csdn.net/tjiyu/article/details/53983650)