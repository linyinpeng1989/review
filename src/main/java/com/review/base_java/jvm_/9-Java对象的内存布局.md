[《深入拆解 Java 虚拟机》10 | Java对象的内存布局](https://time.geekbang.org/column/article/13081)

---

#### 1. Java有多种新建对象的方式：
- new语句：调用构造方法初始化实例字段
- 反射机制：同new语句
- Object.clone：复制已有数据初始化实例字段
- 反序列化：同Object.clone
- Unsafe.allocateInstance：没有初始化实例字段

#### 2. new语句构造对象
使用new构造对象实例，其字节码中包含用来请求内存的new指令，以及用来调用构造器的invokespecial指令。
```
 Foo foo = new Foo();
 0: new           #2                  // class Foo
 3: dup
 4: invokespecial #3                  // Method "<init>":()V
 7: astore_1
 8: return
```
Java构造器的一些特性：
- 如果一个类没有定义任何构造器，则Java编译器会自动添加一个无参构造器
- 子类构造器需要调用父类构造器，无参构造器可以隐式调用（Java编译器自动添加对父类构造器的调用），若父类没有无参构造器，则需要显示地调用父类带参数的构造器
- 父类构造器可以通过super关键字调用，同一个类中的重载构造器可以通过this关键字调用
- 无论显示调用还是隐式调用，都需要作为构造器的第一条语句

通过new指令新建出来的对象，它的内存涵盖了所有父类中的实例字段。也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为父类这些实例字段分配内存。

#### 3. 压缩指针
[[Java JVM] Hotspot GC研究- 64位引用指针压缩技术](https://blog.csdn.net/lqp276/article/details/52231261)

在Java虚拟机中，每个Java对象都有一个对象头，由标记字段（mark word）和类型指针组成。其中，标记字段用以存储Java虚拟机有关该对象的运行数据（哈希码、GC信息、锁信息等），而类型指针则指向该对象的类。

为了尽量减少对象的内存使用量（64位虚拟机中，标记字段和类型指针分别占用64位，即一个Java对象在内存中的额外开销为16字节），使用压缩指针将堆中64位的Java对象指针压缩成32位，额外开销降至12字节。

压缩指针要求 Java 虚拟机堆中对象的起始地址要对齐至 8 的倍数（内存对齐，如果对象用不到8N个字节，则空白部分空间称为对象间的填充）。Java 虚拟机还会对每个类的字段进行重排列（重新分配字段的先后顺序），使得字段也能够内存对齐（进一步减少内存使用量、让字段只出现在同一CPU缓存行中）。

#### 4. 虚共享
假设两个线程分别访问同一对象中不同的 volatile 字段，逻辑上它们并没有共享内容，因此不需要同步。然而，如果这两个字段恰好在同一个缓存行中，那么对这些字段的写操作会导致缓存行的写回，也就造成了实质上的共享。

Java 8 引入了一个新的注释 @Contended，用来解决对象字段之间的虚共享（false sharing）问题。Java 虚拟机会让不同的 @Contended 字段处于独立的缓存行中，因此你会看到大量的空间被浪费掉。


