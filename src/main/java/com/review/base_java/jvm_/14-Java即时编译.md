[《深入拆解 Java 虚拟机》16 | 即时编译（上）](https://time.geekbang.org/column/article/14061)

[《深入拆解 Java 虚拟机》17 | 即时编译（下）](https://time.geekbang.org/column/article/14070)

---

通常而言，代码会先被 Java 虚拟机解释执行，之后反复执行的热点代码则会被即时编译成为机器码，直接运行在底层硬件之上。

#### 1. 分层编译模式
HotSpot 虚拟机包含多个即时编译器 C1、C2 和 Graal（一个实验性质的即时编译器，用以替代C2）。
- Java 7之前，需要根据程序的特性选择对应的即时编译器。对于执行时间较短、或者对启动性能有要求的程序，采用编译效率较快的C1（对应参数 -client）；对于执行时间较长、或者对峰值性能有要求的程序，采用生成代码执行效率较快的C2（对应参数 -server）。
- Java 7 引入了分层编译概念，将Java虚拟机的执行状态分为五个层次。用“C1 代码”来指代由 C1 生成的机器码，“C2 代码”来指代由 C2 生成的机器码，则五个层级分别是：
    - 0.解释执行
    - 1.执行不带profiling的C1代码
    - 2.执行仅带方法调用次数以及循环回边执行次数profiling的C1代码
    - 3.执行带所有profiling的C1代码
    - 4.执行C2代码

通常情况下，C2 代码的执行效率要比 C1 代码的高出 30% 以上。然而，对于 C1 代码的三种状态，按执行效率从高至低则是 1 层 > 2 层 > 3 层。其中 1 层的性能比 2 层的稍微高一些，而 2 层的性能又比 3 层高出 30%。这是因为 profiling 越多，其额外的性能开销越大。


在五个层次的执行状态中，1层和4层为终止状态。当一个方法被终止状态编译过后，如果编译后的代码并没有失效，那么 Java 虚拟机是不会再次发出该方法的编译请求的。


![不同的编译路径](https://static001.geekbang.org/resource/image/c5/e5/c503010c157b7db7596893633b624fe5.png)
- 通常情况下，方法会首先被解释执行，热点方法先被3层的C1编译，然后再被4层的C2编译。
- 如果方法的字节码数目比较少，且 3 层的 profiling 没有可收集的数据。那么Java 虚拟机断定该方法对于 C1 代码和 C2 代码的执行效率相同。在这种情况下，Java 虚拟机会在 3 层编译之后，直接选择用 1 层的 C1 编译。
- 在 C1 忙碌的情况下，Java 虚拟机在解释执行过程中对程序进行 profiling，而后直接由 4 层的 C2 编译。
- 在 C2 忙碌的情况下，方法会被 2 层的 C1 编译，然后再被 3 层的 C1 编译，以减少方法在 3 层的执行时间。


#### 2. 即时编译的触发
Java 虚拟机是根据方法的调用次数以及循环回边（在字节码中，可以简单地理解为往回跳转的指令）的执行次数来触发即时编译的。实际上，Java虚拟机并不会对这些计数器进行同步操作，因此收集而来的执行次数并非精确值，但即时编译的触发并不需要非常精确的数值，只需要该数值足够大即可。

- 在不启用分层编译的情况下，方法调用次数和循环回边次数之和超过参数指定的固定阈值，便会触发即时编译。
- 当启动分层编译时，方法调用次数和循环回边次数之和超过动态阈值（阈值动态调整），便会触发即时编译。

#### 3. OSR编译
除了以方法为单位的即时编译之外，Java 虚拟机还存在着另一种以循环为单位的即时编译，叫做 On-Stack-Replacement（OSR）编译。OSR编译主要基于循环回边的执行次数进行触发，可以用来解决单次调用方法包含热循环的性能优化问题。

OSR 实际上是一种技术，它指的是在程序执行过程中，动态地替换掉 Java 方法栈桢，从而使得程序能够在非方法入口处进行解释执行和编译后的代码之间的切换。

#### 4. Profiling
分层编译中的 0 层、2 层和 3 层都会进行 profiling，收集能够反映程序执行状态的数据。其中，最为基础的便是方法的调用次数以及循环回边的执行次数，它们被用于触发即时编译。此外，0 层和 3 层还会收集用于 4 层 C2 编译的数据，
比如说分支跳转字节码的分支 profile（branch profile），包括跳转次数和不跳转次数，以及非私有实例方法调用指令、强制类型转换 checkcast 指令、类型测试 instanceof 指令，和引用类型的数组存储 aastore 指令的类型 profile（receiver type profile）。
分支 profile 和类型 profile 的收集将给应用程序带来不少的性能开销。

在通常情况下，我们不会在解释执行过程中收集分支 profile 以及类型 profile。只有在方法触发 C1 编译后，Java 虚拟机认为该方法有可能被 C2 编译，才会在该方法的 C1 代码中收集这些 profile。当方法被 3 层 C1 所编译时，
生成的 C1 代码将收集条件跳转指令的分支 profile，以及类型相关指令的类型 profile。在部分极端情况下，Java 虚拟机也会在解释执行过程中收集这些 profile。

基于分支 profile 的优化以及基于类型 profile 的优化都将对程序今后的执行作出假设。这些假设将精简所要编译的代码的控制流以及数据流。在假设失败的情况下，Java 虚拟机将采取去优化，退回至解释执行并重新收集相关的 profile。