[《深入拆解 Java 虚拟机》18 | 即时编译器的中间表达形式](https://time.geekbang.org/column/article/14270)

---

#### 1. 中间表达形式（IR）
在编译原理中，编译器通常分为前端和后端。其中，前端会对所输入的程序进行词法分析、语法分析、语义分析，然后生成中间表达式IR（Intermediate Representation ）；后端会对IR进行优化，然后生成目标代码。

映射到Java中，从Java源代码到最终的机器码实际上经过了两轮编译:
- Java编译器（前端）会对Java源代码进行词法分析、语法分析、语义分析等，最终编译成Java字节码。
- 即时编译器则将Java字节码作为一种IR，并对其进行优化，最终编译成机器码。

不过Java字节码本身并不适合直接作为可供优化的IR，因为Java编译器无法判断赋值是否冗余，导致Java字节码中可能存在冗余代码。现代编译器一般采用静态单赋值（Static Single Assignment，SSA）IR，其特点是每个变量只能被赋值一次，而且只有当变量被赋值之后才能使用。
```
y = 1;
y = 2;
x = y;

// 上述代码对应的SSA形式伪代码如下
y1 = 1;
y2 = 2;
x1 = y2;
```
借助SSA IR，编译器可以通过查找赋值了但是没有使用的变量，对冗余赋值进行识别。另外，SSA IR 对其他优化方式也有很大的帮助，例如常量折叠（constant folding）、常量传播（constant propagation）、强度削减（strength reduction）以及死代码删除（dead code elimination）等。
```
示例：
x1=4*1024 经过常量折叠后变为 x1=4096
x1=4; y1=x1 经过常量传播后变为 x1=4; y1=4
y1=x1*3 经过强度削减后变为 y1=(x1<<1)+x1
if(2>1){y1=1;}else{y2=1;}经过死代码删除后变为 y1=1
```