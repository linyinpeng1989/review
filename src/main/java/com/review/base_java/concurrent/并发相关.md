#### 1. 如下代码为何产生死锁？(DeadLock.java)

```java
public class DeadLock {
    private static int c = 1;

    private static Thread thread = new Thread(new Runnable() {
        @Override
        public void run() {
            c = 2;
            System.out.println(c);
            System.out.println("执行test-thread线程");
        }
    }, "test-thread");

    static {
        thread.start();
        try {
            // join方法作用：阻塞等待thread线程执行完毕
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        System.out.println("OK");
    }
}
```

```
一、 <clinit>方法是由类中静态变量、静态代码块聚合在一起形成的，实际上是一个代码收敛的过程。JVM保证<clinit>方法在多线程环境中被正确地加锁、同步。
二、DeadLock#ClassLockTest类可以证明，当线程A持有ClassLockTest类锁时，线程B依然可以访问ClassLockTest类的静态变量和非synchronized静态方法。
```

①主线程执行main之前，会优先执行< clinit>方法完成类初始化  
②在< clinit>方法执行过程中调用thread.join()，主线程阻塞等待thread线程执行完毕  
③thread线程（外部线程）访问静态域c时，发生死锁

原因：JVM确保<clinit>方法在多线程环境中被正确地加锁、同步，所以在类初始化完成之前，外部线程（thread）无法访问类方法和类变量（即静态方法和静态变量），从而避免类变量尚未构造完成便被使用。
但是本线程（即负责加载并初始化类的线程）是可以访问thread、c等类变量的。


#### 2. 如下代码会输出什么？（SynchronizedTest.java）
```java
public class SynchronizedTest implements Runnable {
    int b = 100;

    synchronized void m1() throws InterruptedException {
        b = 1000;
        Thread.sleep(500);  // 6
        System.out.println("b = " + b);
    }

    synchronized void m2() throws InterruptedException {
        Thread.sleep(250);  // 5
        b = 2000;
    }

    @Override
    public void run() {
        try {
            m1();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws InterruptedException {
        SynchronizedTest synchronizedTest = new SynchronizedTest();
        Thread t = new Thread(synchronizedTest);    // 1
        t.start();  // 2

        synchronizedTest.m2();  // 3
        System.out.println("main thread b = " + synchronizedTest.b);    // 4
    }
}
```
- synchronized用法
    - 指定加锁对象：对给定对象加锁，进入同步代码前需要存活的给定对象的锁（代码块）
    - 直接作用于实例方法：相当于对当前实例加锁，进入同步代码前要获得当前实例的锁
    - 直接作用于静态方法：相当于对当前类加锁，进入同步代码前要获得当前类的锁
    
- Thread.sleep()
    - 使当前线程（即调用该方法的线程）暂停执行一段时间，让其他线程有机会继续执行，但它并不释放对象锁。也就是说如果有synchronized同步块，其他线程任然不能访问共享数据。
    
```text
①当执行1步骤的时候，线程是new状态，还没有开始工作
②当执行2步骤的时候，线程才真正被启动，进入runnable状态（表示可以执行，一切准备就绪），但并不表示一定在CPU上执行，有没有真正执行取决于服务CPU的调度。
③当执行3步骤时，必定先获得锁。
④主线程按顺序执行，所以4步骤只有等到3步骤执行完成后才会执行。


所以，输出结果取决于2步骤、3步骤谁先获得锁。若2步骤先获得锁，则主线程执行到3步骤时阻塞，直到m1执行完成才能继续执行（m2由主线程调用，因此按顺序执行），输出结果如下：

b = 1000  
main thread b = 2000

若3步骤先获得锁，则2步骤阻塞直到3步骤执行完毕，由于sleep阻塞，则输出结果如下：

main thread b = 1000  
b = 1000

```