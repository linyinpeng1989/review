### **死锁相关问题**
- 如下代码为何产生死锁？(DeadLock.java)

```java
public class DeadLock {
    private static int c = 1;

    private static Thread thread = new Thread(new Runnable() {
        @Override
        public void run() {
            c = 2;
            System.out.println(c);
            System.out.println("执行test-thread线程");
        }
    }, "test-thread");

    static {
        thread.start();
        try {
            // join方法作用：阻塞等待thread线程执行完毕
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        System.out.println("OK");
    }
}
```

```
一、 <clinit>方法是由类中静态变量、静态代码块聚合在一起形成的，实际上是一个代码收敛的过程。<clinit>方法是线程安全的，由JVM内部实现。 
二、将thread中关于静态域c的代码注释，程序可以正常运行完毕。
三、DeadLock#ClassLockTest类可以证明，当线程A持有ClassLockTest类锁时，线程B依然可以访问ClassLockTest类的静态变量和非synchronized静态方法。
```

①主线程执行main之前，会优先执行< clinit>方法完成类初始化  
②在< clinit>方法执行过程中调用thread.join()，主线程阻塞等待thread线程执行完毕  
③thread线程访问静态域c时，发生死锁

猜测：JVM确保类加载过程是线程安全的，在类加载并初始化完成之前，外部线程无法访问类方法和类变量（即静态方法和静态变量），从而避免类变量尚未构造完成便被使用。

