### **死锁相关问题**
- 如下代码为何产生死锁？(DeadLock.java)

```java
public class DeadLock {
    private static int c = 1;

    private static Thread thread = new Thread(new Runnable() {
        @Override
        public void run() {
            c = 2;
            System.out.println(c);
            System.out.println("执行test-thread线程");
        }
    }, "test-thread");

    static {
        thread.start();
        try {
            // join方法作用：阻塞等待thread线程执行完毕
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        System.out.println("OK");
    }
}
```

```
一、 <clinit>方法是由类中静态变量、静态代码块聚合在一起形成的，实际上是一个代码收敛的过程。JVM保证<clinit>方法在多线程环境中被正确地加锁、同步。
二、DeadLock#ClassLockTest类可以证明，当线程A持有ClassLockTest类锁时，线程B依然可以访问ClassLockTest类的静态变量和非synchronized静态方法。
```

①主线程执行main之前，会优先执行< clinit>方法完成类初始化  
②在< clinit>方法执行过程中调用thread.join()，主线程阻塞等待thread线程执行完毕  
③thread线程（外部线程）访问静态域c时，发生死锁

原因：JVM确保保证<clinit>方法在多线程环境中被正确地加锁、同步，所以在类初始化完成之前，外部线程（thread）无法访问类方法和类变量（即静态方法和静态变量），从而避免类变量尚未构造完成便被使用。
但是本线程（即负责加载并初始化类的线程）是可以访问thread、c等类变量的。

