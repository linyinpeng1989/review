## 死锁相关问题
- 如下代码为何产生死锁？

```java
public class DeadLock1 {
    private static int c = 1;
    /**
     * lambda表达式创建Runnable匿名对象
     */
    private static Thread thread = new Thread(() -> {
        c = 2;
        System.out.println(c);
    });

    static {
        thread.start();
        try {
            /*
             * join()方法的作用：放弃当前线程的执行，并返回对应的线程继续执行，等对应的线程执行完毕后，再返回当前线程继续执行。
             * 
             * 程序在<clinit>线程中调用thread线程的join方法，则<clinit>线程放弃cpu控制权，并返回thread线程继续执行直到线程thread执行完毕
             * 所以结果是thread线程执行完后，才到<clinit>线程执行，相当于在<clinit>线程中同步thread线程，thread执行完了，<clinit>线程才有执行的机会
             */
            thread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    public static void main(String[] args) {
        System.out.println("OK");
    }
}
```
①由于要优先加载类并初始化，所以main线程需要等待<clinit>线程执行完毕后才能执行。
   
②<clinit>主要是收集static变量和代码块，以线程安全的方式进行初始化操作。在静态代码块中调用thread.join()，则<clinit>线程放弃CPU控制权，等待thread线程执行完毕后才能继续执行，而此时thread对象尚未构造完成，需要
等待<clinit>线程执行完毕。  

③发生死锁，程序无法运行完成，也无法输出任何内容。

- test