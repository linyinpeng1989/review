#### 1. 主题与分区
Kafka的消息通过主题进行分类。主题可以被分为若干个分区，一个分区对应一个提交日志。消息以追加的方式写入分区，然后以先入先出的顺序读取。
由于一个主题一般包含几个分区，因此无法在整个主题范围内保证消息的顺序，但可以保证消息在单个分区内的顺序。

#### 2. 消息写入流程
- 创建ProducerRecord对象，包含主题和内容，也可以指定键和分区
- 使用序列化器进行序列化，这样才能在网络上传输
- 如果在ProducerRecord对象中指定了分区，则分区器不会做任何事情，直接把指定的分区返回；如果没有指定分区，则分区器会根据ProducerRecord对象的键来选择一个分区
- 选好分区以后，消息被添加到一个记录批次中（消息批次中包含的所有消息都有相同的主题和分区）
- 由一个单独的线程负责把这些记录批次发送到相应的broker上

消息分批次写入可以提高效率，但需要在时间延迟和吞吐量之间作出平衡：批次越大，单位时间内处理的消息就越多，单个消息的传输时间就越长。

#### 3. 发送消息的几种模式
- 发送并忘记（fire-and-forget）
    - 将消息发送给服务器，但并不关心它是否正常到达。可能会丢失一部分消息。
- 同步发送
    - 将消息发送给服务器，服务器会返回一个Future对象，调用get()方法进行等待，可以判断消息是否发送成功。
- 异步发送
    - 将消息发送给服务器，并指定一个回调函数，服务器在返回响应时调用该函数。

#### 4. 分区器
- 默认分区器
    - 如果键为null，且使用默认的分区器，则消息将被随机地发送到主体内可用的分区上（轮询算法）。
    - 如果键不为空，且使用默认的分区器，那么Kafka会对键进行散列（使用Kafka自己的散列算法），然后根据散列值把消息映射到特定的分区上。
- 自定义分区器：实现Partitioner接口

#### 5. 消费者与消费者群组
Kafka消息消费主体为消费者群组，消费者群组中包含若干个消费者，每个消费者接收主题中一部分分区的消息，且单条消息只能被相同群组消费一次。

```text
为主题创建大量的分区，并往群组里增加消费者是横向伸缩消费能力的主要方式（提高或降低消费能力）。但是要注意：不要让消费者的数量超过主题分区的数量，多余的消费者只会被闲置。因为每个分区最多只能属于一个消费者。
```


