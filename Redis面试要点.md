#### 1、5中数据结构
 - string：String是最常用的一种数据类型，普通的key/value存储都可以归为此类。
 - hash：Redis的Hash实际是内部存储的Value为一个HashMap，并提供了直接存取这个Map成员的接口。
 - list：list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。
 - set：set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的。
 - sorted set：与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。
 - HyperLogLog（2.8.9 版本新增）： HyperLogLog 是用来做基数统计的算法（即计算某个数据集中不重复元素的个数），其优点是在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，
        每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。但 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。
 
        `什么是基数：比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 `
 
#### 2、Redis删除策略
 - 定时删除：创建一个定时器，定时器在过期时间来临时，立即删除
 - 惰性删除：放任键的过期时间不管，但每次获取元素时都会检查是否过期。过期则删
    - 配置：服务器内置策略
 - 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除过期键。
    - 配置：redis.conf  hz 刷新频率  maxmemory：当内存超过限定，主动触发清除策略

#### 3、主从复制及哨兵机制
redis的复制功能是支持多个数据库之间的数据同步。一类是主数据库（master）一类是从数据库（slave），主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。
通过redis的复制功能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。

哨兵机制：[Redis Sentinel 介绍与部署（哨兵机制）](http://207.246.80.156/?p=423)

#### 4、常见问题
- 穿透
   - 原理：频繁查询一个不存在的数据，由于缓存不命中，导致每次都要查库
   - 解决：持久层查不到数据就缓存空结果，并设置适当的过期时间
   
- 雪崩
   - 原理：缓存雪崩是由于原有缓存失效(过期)，新缓存未到期间。所有请求都去查询数据库，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。
   - 解决：
      - 1.碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。
      同样会导致用户等待超时，这是个治标不治本的方法。
      - 2.给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。缓存标记用来记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存。缓存数据：它的过期时间
      比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。
      
      
  ####  5、Redis和MenCached比较
  - 网络I/O模型
    - Memcached是多线程，非阻塞IO复用的网络模型，分为监听主线程和worker子线程，监听线程监听网络连接，接受请求后，将连接描述字pipe 传递给worker线程进行读写I/O。
    - Redis使用单线程的IO复用模型，主要实现了epoll、kqueue和select，对于单纯只有IO操作来说，单线程可以将速度优势发挥到最大。但进行排序、聚合等操作时，会严重影响整体吞吐量。
  - 内存管理
    - Memcached使用预分配的内存池的方式，使用slab和大小不同的chunk来管理内存，Item根据大小选择合适的chunk存储。
    - Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片。
  - 数据一致性问题
    - Memcached提供了cas命令，可以保证多个并发访问操作同一份数据的一致性问题。
    - Redis是单线程的，提供了事务的功能，可以保证一串命令的原子性，中间不会被任何操作打断。
  - 数据容灾性
    - Redis实现了持久化和主从同步
    - Memcached只是存放在内存中，服务器故障关机后数据就会消失
  - 存储方式及其它方面
    - Memcached基本只支持简单的key-value存储，不支持枚举，不支持持久化和复制等功能
    - Redis除key/value之外，还支持list,set,sorted set,hash等众多数据结构，提供了KEYS进行枚举操作，但不能在线上使用。Redis还同时提供了持久化和复制等功能。
    
    
#### 6、Redis如何保证缓存的都是热点数据（6中内存淘汰机制）
- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- no-enviction（驱逐）：禁止驱逐数据

